# 容器技术与DevOps的关系
```text
去年是高速发展的一年，由于我们有很多新成员的加入，我们的很多开发,测试,运维人员对于在我们DevOps生命周期中各种技术扮演的角色是不够了解的，所以我现在想就这一块大家存在的短板做整体的提升。

这里主要是讲解容器技术与DevOps的关系，这门技术在我们DevOps生命周期中扮演的角色。容器技术不仅限于docker，但是docker目前最为流行，我以docker为例讲容器。
```

## Docker简介

#### 从服务部署的前后今生
```text
1. 物理机部署时代
用纯粹的物理机部署应用，这是所有早期互联网公司经历的一个阶段。一台大型的服务器，如果只部署一个应用，资源比较浪费。
那么我们，将多个应用进程，DB，缓存进程等等都部署在同一个机器上，这样部署能高效的利用好昂贵的物理机，但是这种简单粗暴的方式有一个最大的痛点：进程间资源抢占。
举若干栗子: 
   如果某个进程耗用了100%的CPU资源，那么其他的进程无法提供服务。
   如果一个进程因为突发异常很多，日志把磁盘打满了，那么所有的进程都要挂掉。
对于资源共享时进程间的资源竞争，比较好的解决方式就是：进程间硬件资源隔离，虚拟机技术的出现解决了这个棘手的问题。
```
![物理机](../static/物理机.png)


```text
2. 虚拟机部署时代
虚拟机通过硬件虚拟化，即每台虚拟机事先从物理机分配好cpu核数，内存， 磁盘，每台虚拟机一般只部署一个应用。从而解决了进程间资源隔离的问题。不同的进程在不同的虚拟机上跑，大家相安无事，老死不相往来，自然没有资源冲突。一台物理机会部署多台虚拟机，物理机里的所有虚拟机则依靠虚拟机管理系统进行管理。
  虚拟机技术解决了物理机部署的痛点。但是虚拟机并不是完美的，他也有自己的缺点。大集群部署情况下，软件的版本容易混乱。
  大应用集群的虚拟机第一次安装时，由于操作系统镜像是一样的，所以刚开始，软件的版本和库依赖是统一的。随着时间的推移，开源的软件（tomcat, jdk, nginx）需要逐步升级，于是运维同学开始批量升级集群的软件版本，批量升级可能有遗漏或升级失败。同时有些开发同学会自己登陆机器修改软件的版本或者配置，以满足自己的需求。长此以往，一个应用的集群的虚拟机的软件版本和配置逐渐碎片化。当线上出现问题，需要排查到基础软件层面时，由于软件版本碎片化的问题，导致排查变得很棘手。
  为了解决虚拟机部署的痛点，容器技术应运而生。
```
![虚拟机](../static/虚拟机.png)


```text
3. 容器部署时代
docker容器技术的核心之一在于镜像文件。
镜像文件，通俗的理解就是一个进程运行时依赖的软件文件的集装箱。
应用集群部署时，每台机器首先会拉取指定版本的镜像文件。安装镜像后产生了docker容器。由于所有机器的镜像文件一样，容器的软件版本故而一样。即使开发或运维中途修改了容器的软件版本，但是容器销毁时，软件的改动会随容器的销毁一起湮灭。
容器如果要升级软件版本，那就修改镜像文件。这样部署时集群内所有的机器重新拉取新的镜像，软件因此跟着一起升级。软件版本混乱的问题，到docker这里，也就得到了完美的解决。
```
![容器](../static/容器化.png)

#### Docker的具体简介
![docker](../static/docker.jpg)

#### Docker在公司起的作用
```text
1. 镜像仓库
2. 服务/镜像部署
```

## Docker与开发/测试的关系
```text
1. 前端


2. 后端


3. 测试
```

## Docker与线上生产Kubernetes集群关系
```text

```

## 干货,演示环节
```text
指路====> https://github.com/Min65535/demo/tree/master/dfm-test/docker
```

## 提问与解答环节
```text
一个疑问：有了容器技术，生产环境为何还需要部署虚拟机？
  虚拟机能做到硬件资源的彻底隔离，docker不行。虚拟机和docker各取长处，最佳CP。
```